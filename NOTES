to do:
   * make sure that all operations leave the original stack elements
     unaltered, so that dup() works properly.

   * seems like rpc_interface.gen_buffer should be a linked list rather
     than an array.  Using an array has the following disadvantages:
         - places a limit on maximum array size
         - wasteful of memory
         - need to spend time clearing the array every time an item is
           entered (with linked list, we can just throw away the old
           list...)
     If a list is used, then the head has to be the matrix element
     currently being edited; this is the last item that would be
     printed, so having it at the head of the list seems problematic.
     Maybe we can get around this by building up the display string in
     reverse order, i.e.
                  3]]
               2, 3]]
            1][2, 3]]
       [[0, 1][2, 3]]
     If that doesn't work, we'd have to List.rev before creating the
     display string.  Which, of course, is time-consuming for big lists.
     (Need a doubly-linked list in the standard library!)


Extended function entry notes:
   * When entering an extended function, the characters that have been typed
     should be boldfaced.  That way the user can differentiate between the part
     that has been typed and the part that has been completed.

   * Extended function entry is modal: either you are entering data, or you are
     entering an extended function, not both.  Hitting the "escape extended
     function" key will cancel it completely and put the user back in data entry
     mode; hitting enter will immediately (1) push any data in the entry buffer
     and (2) apply the extended function.

   * An extended *command* can only be entered when there is no data in the
     entry buffer.

   * Hitting backspace during extended function entry will remove the last
     character that was typed, and may generate a different matching function as
     a result.

   * regexps can be used to do the matching.


Potential improvements for rpc2:

   * based on GSL rather than ccmath

   * arbitrary precision integers

   * arbitrary precision rationals (is this useful?)

   * separate threads for GUI and calc, so computations
     can be interrupted (useful?)

   * slightly improved UI

   * better error messages

------------------------------------------------------------------------

New interface ideas (see "display-sample.txt"):

   * Design for 80 columns; separate window panels for stack (right
     (side?) and some sort of status/help window (left side)

   * Reserve a function entry key.  The current behavior allows one
     to just start typing a function name, e.g. "ex" -> exp( ).  This
     behavior will not work well with custom keybindings.

     New behavior: use a key such as 'f' to indicate function entry.
     So the user types "fex" -> exp( ).  It involves more keypresses
     initially, but there will be fewer key binding conflicts to worry
     about.  Also, the extra keypresses could be factored away if some
     sort of macro system is involved, e.g.

         macro "x" "fex<enter>"

     would permit the user to bind exp to a single press of 'x'.

   * What about the status panel?  It should contain a list of
     calculator flags, for one thing (integer arithmetic base, complex
     display format, etc.), but this won't take up much room.  Perhaps a
     list of common function names?

   * Color is probably not very helpful; boldface seems to work well to
     set things off.

   * Provide smarter errors when possible, like "incompatible matrix
     dimensions for MULT" or "incompatible arguments for ADD"





# arch-tag: DO_NOT_CHANGE_26d2d56c-11b2-40d0-aa03-3bfc572cf9e0 
